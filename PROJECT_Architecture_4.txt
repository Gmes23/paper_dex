================================================================================
HYPERLIQUID ORDER BOOK WIDGET - UPDATE 4 DOCUMENTATION
================================================================================

This document covers the latest architectural changes and new features.
Major updates include:

1. Price Chart Component (New Feature - Lightweight Charts)
2. Chart Utilities for Candle Aggregation (New Library)
3. New Dependencies: lightweight-charts, pg (PostgreSQL)
4. Refined Layout: Chart + PositionsTable on Left, OrderBook on Right
5. TradeTab Cleanup (Removed Commented Code)
6. All Previously Added Features (Position Management, Mark Price, etc.)

================================================================================
NEW DEPENDENCIES (package.json)
================================================================================

ADDED:
------
- lightweight-charts: ^5.1.0  (TradingView charting library)
- pg: ^8.18.0                 (PostgreSQL client - for future DB features)
- @types/pg: ^8.16.0          (TypeScript types for pg)
- autoprefixer: ^10.4.24      (CSS autoprefixer)
- postcss: ^8.5.6             (CSS processor)

These additions enable:
1. Professional candlestick charts with volume
2. Future database persistence for positions/trades
3. Better CSS processing


================================================================================
ARCHITECTURE OVERVIEW
================================================================================

LAYOUT STRUCTURE:
-----------------
+----------------------------------+---------------------------+
|           LEFT COLUMN            |       RIGHT COLUMN        |
|  +----------------------------+  |  +---------------------+  |
|  |       PriceChart           |  |  |  OrderBookHeader    |  |
|  |  - Candlestick chart       |  |  +---------------------+  |
|  |  - Volume histogram        |  |  |  OrderBookTable     |  |
|  |  - Interval selector       |  |  |  OR TradesTable     |  |
|  +----------------------------+  |  +---------------------+  |
|  |     PositionsTable         |  |  |     TradeTab        |  |
|  |  - Open positions          |  |  +---------------------+  |
|  |  - Real-time PNL           |  |  |     Footer          |  |
|  +----------------------------+  |  +---------------------+  |
+----------------------------------+---------------------------+


DATA FLOW:
----------
WebSocket (trades) -----> useTrades -----> trades[]
                                              |
                                              v
                                    aggregateTradesToCandles()
                                              |
                                              v
                                         PriceChart
                                              |
                                              v
                                    lightweight-charts render


================================================================================
NEW FILE: lib/chartUtils.ts
================================================================================

PURPOSE:
--------
Utility functions for aggregating trade data into OHLCV candlestick format
for display in the price chart.

KEY EXPORTS:
------------
- TimeInterval: Type for chart intervals ('1m', '5m', '15m', '1h', etc.)
- CandleData: OHLCV candle structure
- aggregateTradesToCandles(): Converts trades to candles

ALGORITHM:
----------
1. Sort trades by time
2. Group trades into time buckets based on interval
3. For each bucket:
   - First trade price = open
   - Highest price = high
   - Lowest price = low
   - Last trade price = close
   - Sum of sizes = volume
4. Return sorted array of candles

CODE:
-----
import type { ProcessedTrade } from "./types";


// lib/chartUtils.ts

export type TimeInterval = '1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M';

// Keep your existing CandleData type - it matches!
export type CandleData = {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
}

/*
    Duration of chart options/

    TODO: give user the ability to add custom option
*/

function getIntervals(interval: TimeInterval): number {
    const min = 60 * 1000;

    switch (interval) {
        case '1m': return min;
        case '5m': return 5 * min;
        case '15m': return 15 * min;
        case '1h': return 60 * min;
        default: return min;
    }
}

type CandleMap =
    Omit<CandleData, 'time'> & {
        trades: ProcessedTrade[];
    };


export function aggregateTradesToCandles(
    trades: ProcessedTrade[],
    interval: TimeInterval
): CandleData[] {
    if (trades.length === 0) return [];



    const intervalMs = getIntervals(interval);

    const candleMap = new Map<number, CandleMap>();

    const today = new Date();
    const todayDateString = today.toISOString().split('T')[0]

    const sortedTrades = [...trades].sort((a, b) => {
        const timeA = new Date(`${todayDateString}T${a.time}`).getTime();
        const timeB = new Date(`${todayDateString}T${b.time}`).getTime();
        return timeA - timeB;
    });
    // DEBUG
    console.log('Today date string:', todayDateString);
    console.log('First 3 trades:', trades.slice(0, 3));




    sortedTrades.forEach((trade) => {
        const price = parseFloat(trade.price);

        const dateTimeString = `${todayDateString}T${trade.time}`;
        const timestamp = new Date(dateTimeString).getTime();

        if (!Number.isFinite(timestamp) || !Number.isFinite(price)) {
            console.warn('Skipping invalid trade:', {
                time: trade.time,
                dateTimeString,
                timestamp,
                price
            });
            return;
        }


        const bucketTime = Math.floor(timestamp / intervalMs) * intervalMs;

        const existing = candleMap.get(bucketTime);

        if (!existing) {

            candleMap.set(bucketTime, {
                trades: [trade],
                open: price,
                high: price,
                low: price,
                close: price,
                volume: trade.size
            });
        } else {

            existing.trades.push(trade);
            existing.high = Math.max(existing.high, price);
            existing.low = Math.min(existing.low, price);
            existing.close = price;
            existing.volume += trade.size;
        }
    });


    // Converting to array and formating in the format lightweight charts takes in
    const postProcessData = Array.from(candleMap.entries())
        .sort((a, b) => a[0] - b[0])
        .map(([timestamp, candle]) => {
            // Validate candle data
            if (candle.high < Math.max(candle.open, candle.close)) {
                console.error('Invalid candle: high too low', {
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    close: candle.close,
                    bucket: new Date(timestamp).toISOString()
                });
            }
            if (candle.low > Math.min(candle.open, candle.close)) {
                console.error('Invalid candle: low too high', {
                    open: candle.open,
                    high: candle.high,
                    low: candle.low,
                    close: candle.close,
                    bucket: new Date(timestamp).toISOString()
                });
            }

            return {
                time: formatTimeForChart(timestamp),
                open: candle.open,
                high: candle.high,
                low: candle.low,
                close: candle.close,
                volume: candle.volume,
            };
        });

    console.log(`Generated ${postProcessData.length} candles from ${trades.length} trades`);

    return postProcessData;

}


/**
 * Format timestamp for Lightweight Charts
 * Lightweight Charts accepts: 'YYYY-MM-DD' or Unix timestamp (seconds)
 */
function formatTimeForChart(timestamp: number): number {
    // Return Unix timestamp in seconds as a NUMBER, not string
    return Math.floor(timestamp / 1000);
}


================================================================================
NEW FILE: components/Chart/Chart.tsx
================================================================================

PURPOSE:
--------
Professional candlestick chart with volume histogram using TradingView's
Lightweight Charts library.

KEY FEATURES:
-------------
1. CANDLESTICK SERIES:
   - Green candles for up (close >= open)
   - Red candles for down (close < open)
   - Wick colors match candle colors

2. VOLUME HISTOGRAM:
   - Positioned at bottom (scaleMargins: top 0.8)
   - Semi-transparent colors (green/red with 50% opacity)

3. INTERVAL SELECTOR:
   - 1m, 5m, 15m, 1h options
   - Active interval highlighted in teal

4. REAL-TIME UPDATES:
   - First load: setData() for full history
   - Subsequent: update() for newest candle only
   - Prevents re-rendering entire chart

5. LOADING STATE:
   - Spinner overlay while loading
   - "No chart data available" for empty state

6. RESPONSIVE:
   - Resizes with window
   - Container ref for width tracking

ARCHITECTURE PATTERN:
---------------------
- Chart created ONCE in useEffect (persists across renders)
- Refs track chart, series, and state
- Data changes trigger update() not recreation
- Cleanup properly removes chart on unmount

CODE:
-----
'use client';

import { useEffect, useRef } from 'react';
import {
  createChart,
  ColorType,
  IChartApi,
  ISeriesApi,
  CandlestickSeries,
  HistogramSeries,
} from 'lightweight-charts';
import type { TimeInterval, CandleData } from '@/lib/chartUtils';

interface PriceChartProps {
  candles: CandleData[];
  loading: boolean;
  symbol: string;
  interval: TimeInterval;
  onIntervalChange: (interval: TimeInterval) => void;
}

export function PriceChart({
  candles,
  loading,
  symbol,
  interval,
  onIntervalChange,
}: PriceChartProps) {
  const chartContainerRef = useRef<HTMLDivElement>(null);

  const chartRef = useRef<IChartApi | null>(null);
  const candleSeriesRef = useRef<ISeriesApi<'Candlestick'> | null>(null);
  const volumeSeriesRef = useRef<ISeriesApi<'Histogram'> | null>(null);

  // Track if we already set full history once
  const didSetInitialDataRef = useRef(false);

  // Track last rendered candle time
  const lastRenderedTimeRef = useRef<number | null>(null);

  // Reset when interval or symbol changes
  useEffect(() => {
    didSetInitialDataRef.current = false;
    lastRenderedTimeRef.current = null;
  }, [interval, symbol]);

  // Create chart ONCE (but only when container exists)
  useEffect(() => {
    if (!chartContainerRef.current) return;

    // If already created, don't recreate (important in dev / strict mode timing)
    if (chartRef.current) return;

    const container = chartContainerRef.current;

    const chart = createChart(container, {
      width: container.clientWidth,
      height: 400,
      layout: {
        background: { type: ColorType.Solid, color: '#131722' },
        textColor: '#d1d4dc',
      },
      grid: {
        vertLines: { color: '#1a1e27' },
        horzLines: { color: '#1a1e27' },
      },
      rightPriceScale: { borderColor: '#2B2B43' },
      timeScale: {
        borderColor: '#2B2B43',
        timeVisible: true,
        secondsVisible: false,
      },
    });

    const candleSeries = chart.addSeries(CandlestickSeries, {
      upColor: '#26a69a',
      downColor: '#ef5350',
      borderVisible: false,
      wickUpColor: '#26a69a',
      wickDownColor: '#ef5350',
    });

    const volumeSeries = chart.addSeries(HistogramSeries, {
      priceFormat: { type: 'volume' },
      priceScaleId: '',
    });

    volumeSeries.priceScale().applyOptions({
      scaleMargins: { top: 0.8, bottom: 0 },
    });

    chartRef.current = chart;
    candleSeriesRef.current = candleSeries;
    volumeSeriesRef.current = volumeSeries;

    const handleResize = () => {
      if (!chartRef.current || !chartContainerRef.current) return;
      chartRef.current.applyOptions({
        width: chartContainerRef.current.clientWidth,
      });
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      chart.remove();
      chartRef.current = null;
      candleSeriesRef.current = null;
      volumeSeriesRef.current = null;
    };
  }, []);

  // Feed data:
  // - first load uses setData
  // - subsequent updates use update(lastCandle)
  useEffect(() => {
    const candleSeries = candleSeriesRef.current;
    const volumeSeries = volumeSeriesRef.current;

    if (!candleSeries || !volumeSeries) return;
    if (loading) return;
    if (!candles || candles.length === 0) return;

    // First time: setData once (fast + correct)
    if (!didSetInitialDataRef.current) {
      candleSeries.setData(candles as any);

      const volumeData = candles.map((c) => ({
        time: c.time as any,
        value: c.volume,
        color: c.close >= c.open ? '#26a69a80' : '#ef535080',
      }));
      volumeSeries.setData(volumeData as any);

      chartRef.current?.timeScale().fitContent();

      didSetInitialDataRef.current = true;
      lastRenderedTimeRef.current = candles[candles.length - 1]?.time ?? null;
      return;
    }

    // Realtime: update only the newest candle
    const lastCandle = candles[candles.length - 1];
    if (!lastCandle) return;

    candleSeries.update(lastCandle as any);
    volumeSeries.update({
      time: lastCandle.time as any,
      value: lastCandle.volume,
      color: lastCandle.close >= lastCandle.open ? '#26a69a80' : '#ef535080',
    } as any);

    lastRenderedTimeRef.current = lastCandle.time;
  }, [candles, loading]);

  const showEmpty = !loading && candles.length === 0;

  return (
    <div className="bg-[#131722] p-4 rounded-lg mb-4">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-white">{symbol}/USDC</h2>

        <div className="flex gap-2">
          {(['1m', '5m', '15m', '1h'] as TimeInterval[]).map((int) => (
            <button
              key={int}
              onClick={() => onIntervalChange(int)}
              disabled={loading}
              className={`px-3 py-1 rounded transition ${
                interval === int
                  ? 'bg-teal-500 text-white'
                  : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
              } ${loading ? 'opacity-50 cursor-not-allowed' : ''}`}
            >
              {int}
            </button>
          ))}
        </div>
      </div>

      <p className="text-xs text-gray-500 mb-2">
        Displaying {candles.length} candles
      </p>

      {/* ALWAYS mounted container */}
      <div className="relative rounded overflow-hidden">
        <div ref={chartContainerRef} className="h-[400px]" />

        {/* overlay states */}
        {loading && (
          <div className="absolute inset-0 flex items-center justify-center text-gray-400 bg-[#131722]/80">
            <div className="text-center">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-500 mx-auto mb-4"></div>
              <p>Loading chart data...</p>
            </div>
          </div>
        )}

        {showEmpty && (
          <div className="absolute inset-0 flex items-center justify-center text-gray-400 bg-[#131722]/80">
            <p>No chart data available</p>
          </div>
        )}
      </div>
    </div>
  );
}


================================================================================
UPDATED: app/page.tsx
================================================================================

PURPOSE:
--------
Main orchestrator now includes PriceChart above PositionsTable.

KEY CHANGES:
------------
1. NEW IMPORT:
   - PriceChart from '@/components/Chart/Chart'

2. NEW LAYOUT:
   - Left column: PriceChart + PositionsTable
   - Right column: OrderBookHeader + OrderBook/Trades + TradeTab

3. CHART DATA FLOW:
   - trades[] passed to PriceChart
   - Chart aggregates trades into candles internally
   (Note: In actual implementation, parent should aggregate and pass candles)

CODE:
-----
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { OrderBookHeader } from '@/components/OrderBook/OrderBookHeader';
import { OrderBookTable } from '@/components/OrderBook/OrderBookTable';
import { TradesTable } from '@/components/OrderBook/TradesTable';
import { TradeTab } from '@/components/TradeTab/TradeTab';
import { PositionsTable } from '@/components/PositionsTable/PositionsTable';
import { PriceChart } from '@/components/Chart/Chart';


import { useWebSocket } from '@/hooks/useWebSocket';
import { useOrderBookState } from '@/hooks/useOrderBookState';
import { useTrades } from '@/hooks/useTrades';

import type { Symbol, Tab, Denomination, TradeFormState, Position } from '@/lib/types';

export default function OrderBook() {
  const [symbol, setSymbol] = useState<Symbol>('BTC');
  const [priceGrouping, setPriceGrouping] = useState<number>(1);
  const [activeTab, setActiveTab] = useState<Tab>('orderbook');
  const [denomination, setDenomination] = useState<Denomination>('asset');
  const [openMenu, setOpenMenu] = useState<string | null>(null);
  // Custom hooks
  const {
    fixedBids,
    fixedAsks,
    bestBid,
    bestAsk,
    spread,
    maxBidTotal,
    maxAskTotal,
    processOrderBook,
    error
  } = useOrderBookState({ symbol, priceGrouping });

  const { trades, processTrades, resetTrades } = useTrades({ symbol });

  const { isConnected } = useWebSocket({
    symbol,
    onOrderBookUpdate: processOrderBook,
    onTradesUpdate: processTrades
  });

  const [markPrice, setMarkPrice] = useState<number | null>(null);
  const bestBidRef = useRef(bestBid);
  const bestAskRef = useRef(bestAsk);


  const currentMarkPriceRef = useRef<number | null>(null);


  //User positions
  const [userPositionData, setUserPositionData] =
    useState<Position[]>([]);

  //state for when buy/selling TradeTab
  const [tradeForm, setTradeForm] = useState<TradeFormState>({
    tradeAsset: symbol,
    inputPrice: '',
    size: '',
    activeTradeTab: 'Long',
    markPrice: null,
    PNL: null
  });

  const [positionsPNL, setPositionsPNL] = useState<(number | string)[] | null>(null);


  //actually we should throttle this, or rather wait until user finish making changees?
  const addPosition = useCallback(() => {
    const position = {
      id: `${Date.now()}-0x${Math.random().toString(36).substring(2, 9)}`,
      date: Date.now(),
      ...tradeForm
    }
    setUserPositionData(prevState => [...prevState, position])
  }, [tradeForm]);

  useEffect(() => {
    bestBidRef.current = bestBid;
    bestAskRef.current = bestAsk;
  }, [bestBid, bestAsk]);


  useEffect(() => {
    setTradeForm(prevState => ({
      ...prevState,
      tradeAsset: prevState.tradeAsset !== 'USDC' ? symbol : 'USDC'
    }));
  }, [symbol]);

  // Reset trades when symbol changes
  useEffect(() => {
    resetTrades();
    setPriceGrouping(symbol === 'BTC' ? 1 : 0.1);
  }, [symbol, resetTrades]);

  useEffect(() => {

    const useTrottleId = setInterval(() => {
      console.log(bestBidRef.current)

      if (bestBidRef.current && bestAskRef.current) {

        currentMarkPriceRef.current = (bestBidRef.current + bestAskRef.current) / 2;

        setMarkPrice(currentMarkPriceRef.current);

        if (userPositionData && currentMarkPriceRef.current !== null) {
          const pnl = userPositionData.map((position) => {

            const checkValid = (currentMarkPriceRef.current ?? "N/A")
            const profit = checkValid !== "N/A" ? checkValid - parseInt(position.inputPrice) : "N/A";
            return profit;
          })
          setPositionsPNL(pnl)
          console.log(positionsPNL)
        }
      }
    }, 500)

    return () => {
      clearInterval(useTrottleId);
    }
    // i have hard time always thinking what depency is needed for my hooks?
  }, [userPositionData])

  const callbackTradeForm = useCallback((value: Partial<TradeFormState>) => {
    setTradeForm(prevState => ({ ...prevState, ...value }))
  }, [])


  return (
    <div className="min-h-screen bg-[#0a0e13] text-white p-4">




      <div className="grid grid-cols-2 gap-0">

        <div>
          <PriceChart
            trades={trades}
            symbol={symbol}

          />
          <PositionsTable
            userPositions={userPositionData}
            markPrice={markPrice}
            positionsPNL={positionsPNL}
          />
        </div>



        <div className="max-w-l mx-[2.75rem]">
          <OrderBookHeader
            symbol={symbol}
            setSymbol={setSymbol}
            priceGrouping={priceGrouping}
            setPriceGrouping={setPriceGrouping}
            activeTab={activeTab}
            setActiveTab={setActiveTab}
            denomination={denomination}
            setDenomination={setDenomination}
            isConnected={isConnected}
            openMenu={openMenu}
            setOpenMenu={setOpenMenu}
          />

          {activeTab === 'orderbook' ? (
            <OrderBookTable
              fixedAsks={fixedAsks}
              fixedBids={fixedBids}
              spread={spread}
              maxAskTotal={denomination === 'asset' ? maxAskTotal.asset : maxAskTotal.usdc}
              maxBidTotal={denomination === 'asset' ? maxBidTotal.asset : maxBidTotal.usdc}
              denomination={denomination}
              symbol={symbol}
              error={error}
              onPriceSelect={(price) => callbackTradeForm({ inputPrice: price })}
            />
          ) : (
            <TradesTable
              trades={trades}
              denomination={denomination}
              symbol={symbol}
            />
          )}

          <TradeTab
            symbol={symbol}
            openMenu={openMenu}
            setOpenMenu={setOpenMenu}
            onTradeFormChange={callbackTradeForm}
            tradeForm={tradeForm}
            onPositionSubmit={addPosition}
          />

          {/* Footer */}
          <div className="mt-4 text-center text-xs text-gray-600">
            {isConnected ? (
              <span className="text-green-500">Live</span>
            ) : (
              <span className="text-red-500">Disconnected</span>
            )}
          </div>
        </div>

      </div>
    </div>
  );
}


================================================================================
UPDATED: components/TradeTab/TradeTab.tsx
================================================================================

PURPOSE:
--------
Cleaned up version - removed all commented code from previous iterations.

CODE:
-----
import type { Symbol, TradeFormState } from '@/lib/types';
import { Dropdown } from '@/components/ui/Dropdown';

interface TradeTableProps {
    symbol: Symbol;
    openMenu: string | null;
    setOpenMenu: (menu: string | null) => void;
    onTradeFormChange: (value: Partial<TradeFormState>) => void;
    tradeForm: TradeFormState;
    onPositionSubmit: () => void;
}

export function TradeTab({
    symbol,
    setOpenMenu,
    openMenu,
    onTradeFormChange,
    tradeForm,
    onPositionSubmit
}: TradeTableProps) {




    return (
        <div className="grid grid-cols-6 bg-[#131722] text-white">
            <div>
                cross
            </div>
            <div>
                20x
            </div>
            <div>
                classic
            </div>
            <div>
                Market
            </div>
            <div>
                Limit
            </div>
            <div>
                Pro
            </div>

            <div className="col-span-6 flex justify-center">
                <button
                    className={`min-w-[11rem] min-h-[2.75rem] rounded-xl cursor-pointer transition ${tradeForm.activeTradeTab === 'Long' ? 'bg-teal-500' : 'bg-gray-400'}`}
                    onClick={() =>
                    onTradeFormChange({activeTradeTab:'Long'})}>

                    Buy/Long
                </button>

                <button className={`min-w-[11rem] min-h-[2.75rem] rounded-xl
                cursor-pointer transition ${tradeForm.activeTradeTab === 'Short' ? 'bg-rose-400' : 'bg-gray-400'}`}
                    onClick={() => onTradeFormChange({activeTradeTab: 'Short'})
                    }>
                    Sell/Short
                </button>
            </div>

            <div className="col-span-6 flex flex-col gap-1 p-[1rem]">
                <div className="flex justify-between ">
                    <div>
                        Avalaible to Trade
                    </div>
                    <div>
                        3000
                    </div>
                </div>

                <div className="flex justify-between">
                    <div>
                        Current Position
                    </div>
                    <div>
                        3000
                    </div>
                </div>
            </div>

            <div className="col-span-6 flex flex-col gap-2">
                <div className="relative w-full
                bg-transparent border rounded-xl flex text-white justify-between p-2
                transition-colors
                hover:border-teal-400
                focus-within:border-teal-400
                focus-within:ring-1
                focus-within:ring-teal-400
                ">
                    {/* Fake placeholder */}
                    {!tradeForm.inputPrice && (
                        <span className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-400 pointer-events-none">
                            Price (USDC)
                        </span>
                    )}
                    <input
                        name="inputPrice"
                        id="inputPriceField"
                        className="w-full bg-transparent appearance-none outline-none text-right pr-2"
                        type="text"
                        inputMode="numeric"
                        pattern="[0-9]*"
                        value={tradeForm.inputPrice}
                        onChange={(e) => {
                            const onlyNumbers = e.target.value.replace(/\D/g, '');
                            onTradeFormChange({inputPrice: onlyNumbers});
                        }}
                    />
                    <button className="text-teal-400 mr-2">
                        Mid
                    </button>

                </div>

                <div className="relative w-full
                bg-transparent border rounded-xl flex text-white justify-between p-2
                transition-colors
                hover:border-teal-400
                focus-within:border-teal-400
                focus-within:ring-1
                focus-within:ring-teal-400
                ">
                    {/* Fake placeholder */}
                    {!tradeForm.size && (
                        <span className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-400 pointer-events-none">
                            Size
                        </span>
                    )}
                    <input
                        name="size"
                        id="sizeField"
                        className="w-full text-right bg-transparent appearance-none outline-none"
                        value={tradeForm.size}
                        onChange={(e) => {
                            const onlyNumbers = e.target.value.replace(/\D/g, '');

                            onTradeFormChange({size: onlyNumbers})
                        }}
                    />
                    <Dropdown
                        value={tradeForm.tradeAsset}
                        onChange={(val) => {
                            onTradeFormChange({tradeAsset: val})
                            setOpenMenu(null)
                        }}
                        options={[
                            { key: symbol + '1', label: symbol, value: symbol },
                            { key: 'USDC-1', label: 'USDC', value: 'USDC' }
                        ]}
                        isOpen={openMenu === 'tradeAsset'}
                        onToggle={() => {
                            setOpenMenu(openMenu === 'tradeAsset' ? null : 'tradeAsset')
                        }}
                    />
                </div>
            </div>
            <div className="col-span-6 flex justify-center">
                <button
                className={`${tradeForm.activeTradeTab === "Long" ? 'bg-green-400' : 'bg-red-400'} cursor-pointer text-white rounded-2xl min-w-[11rem] min-h-[2.75rem] m-2`}
                onClick={onPositionSubmit}
                >
                {tradeForm.activeTradeTab === "Long" ? 'Long' : 'Short'}
                </button>
            </div>
        </div>
    )
}


================================================================================
EXISTING FILES (Unchanged from Update 3)
================================================================================

The following files remain the same as documented in PROJECT_Architecture_3.txt:

- lib/types.ts (TradeFormState, Position interfaces)
- workers/orderbook.worker.ts (bestBid/bestAsk extraction)
- hooks/useOrderBookState.tsx (Web Worker with message queuing)
- hooks/useTrades.tsx
- hooks/useWebSocket.tsx
- components/OrderBook/OrderBookTable.tsx
- components/OrderBook/OrderBookRow.tsx
- components/OrderBook/TradesTable.tsx
- components/OrderBook/OrderBookHeader.tsx
- components/OrderBook/SpreadIndicator.tsx
- components/PositionsTable/PositionsTable.tsx
- components/ui/Dropdown.tsx
- components/ui/TabSelector.tsx


================================================================================
COMPLETE FILE REFERENCE (All Current Code)
================================================================================

For completeness, here are all the key files with their current code:

--------------------------------------------------------------------------------
lib/types.ts
--------------------------------------------------------------------------------
export interface OrderBookLevel {
    px: string;
    sz: string;
    n: number;
  }

  export interface OrderBookData {
    coin: string;
    levels: [OrderBookLevel[], OrderBookLevel[]];
    time: number;
  }

  export interface ProcessedLevel {
    price: number;
    size: number;
    sizeUsdc: number;
    total: number;
    totalUsdc: number;
    priceStr: string;
    isNew: boolean;
  }

  export interface TradeData {
    coin: string;
    side: string;
    px: string;
    sz: string;
    time: number;
    hash: string;
  }

  export interface ProcessedTrade {
    price: string;
    size: number;
    sizeUsdc: number;
    side: 'buy' | 'sell';
    time: string;
    id: string;
  }

  export interface TradeFormState {
    tradeAsset: Symbol | 'USDC',
    inputPrice: string;
    size: string;
    activeTradeTab: 'Long' | 'Short';
    markPrice: number | null;
    PNL: number | null;
  }

  export interface Position {
    id: string;
    date: number;
    tradeAsset: Symbol | 'USDC',
    inputPrice: string;
    size: string;
    activeTradeTab: 'Long' | 'Short';
  }

  export type Symbol = 'BTC' | 'ETH';
  export type Tab = 'orderbook' | 'trades';
  export type Denomination = 'asset' | 'usdc';


--------------------------------------------------------------------------------
hooks/useOrderBookState.tsx
--------------------------------------------------------------------------------
// hooks/useOrderBookState.tsx
'use client';

import { useState, useRef, useMemo, useCallback, useEffect } from 'react';
import { NUM_ROWS } from '@/lib/constants';
import type { OrderBookData, ProcessedLevel, Symbol } from '@/lib/types';

interface UseOrderBookStateProps {
  symbol: Symbol;
  priceGrouping: number;
}

interface ProcessedDataProps {
  bids: ProcessedLevel[];
  asks: ProcessedLevel[];
  bestBid: number;
  bestAsk: number;
  spread: { value: number; percentage: number } | null;
  maxBidTotal: { asset: number; usdc: number };
  maxAskTotal: { asset: number; usdc: number };
}
export function useOrderBookState({
  symbol,
  priceGrouping
}: UseOrderBookStateProps) {

  // ONLY store worker results
  const [processedData, setProcessedData] = useState< ProcessedDataProps| null>(null);

  const workerRef = useRef<Worker | null>(null);
  const currentSymbolRef = useRef<string>(symbol);

  //fallback for error
  const [workerError, setWorkError] = useState<string | null>(null);

  //track if worker is in progress
  const isProcessingRef = useRef(false);

  //store the most recent data while worker is busy
  const pendingDataRef = useRef<OrderBookData | null>(null);
  const priceGroupingRef = useRef(priceGrouping);

  useEffect(() => {
    priceGroupingRef.current = priceGrouping;
  }, [priceGrouping]);


  // Create worker once
  useEffect(() => {
    workerRef.current = new Worker(
      new URL('../workers/orderbook.worker.ts', import.meta.url)
    );

    workerRef.current.onmessage = (e) => {
      if (e.data.symbol !== currentSymbolRef.current) {
        console.warn("Ignoring stale worker result for", e.data.symbol);
        return;
      }
      setProcessedData(e.data);
      isProcessingRef.current = false;

      if(pendingDataRef.current) {
        const dataToProcess = pendingDataRef.current;

        //why process it now?
        isProcessingRef.current = true;
        workerRef.current?.postMessage({
          rawBids: dataToProcess.levels[0],
          rawAsks: dataToProcess.levels[1],
          priceGrouping: priceGroupingRef.current,
          symbol: currentSymbolRef.current
        })
      }
    };

    workerRef.current.onerror = (error) => {
      console.error('Worker Error:', error);
      setWorkError("Calculating engine failed. Using fallback...")
    };

    return () => {
      workerRef.current?.terminate();
    };
  }, []);

  // Send data to worker (NO processing here!)
  const processOrderBook = useCallback((data: OrderBookData) => {
    if (data.coin !== currentSymbolRef.current) return;

    if(isProcessingRef.current) {
      pendingDataRef.current = data;
      return;
    }

    isProcessingRef.current = true;
    workerRef.current?.postMessage({
      rawBids: data.levels[0],
      rawAsks: data.levels[1],
      priceGrouping: priceGroupingRef.current,
      symbol: currentSymbolRef.current
    });
  }, [priceGrouping]);

  // Update symbol reference
  useEffect(() => {
    currentSymbolRef.current = symbol;
    setProcessedData(null); // Clear old data
    pendingDataRef.current = null;
    isProcessingRef.current = false;
  }, [symbol]);

  // Format for display (cheap operation, OK on main thread)
  const fixedAsks = useMemo(() => {
    if (!processedData) return Array(NUM_ROWS).fill(null);

    const rows: (ProcessedLevel | null)[] = Array(NUM_ROWS).fill(null);
    processedData.asks.forEach((ask, i) => {
      rows[NUM_ROWS - 1 - i] = ask;
    });
    return rows;
  }, [processedData?.asks]);

  const fixedBids = useMemo(() => {
    if (!processedData) return Array(NUM_ROWS).fill(null);

    const rows: (ProcessedLevel | null)[] = Array(NUM_ROWS).fill(null);
    processedData.bids.forEach((bid, i) => {
      rows[NUM_ROWS - 1 - i] = bid;
    });
    return rows;
  }, [processedData?.bids]);



  // Return worker results
  return {
    bids: processedData?.bids || [],
    asks: processedData?.asks || [],
    fixedBids,
    fixedAsks,
    bestBid: processedData?.bestBid || null,
    bestAsk: processedData?.bestAsk || null,
    spread: processedData?.spread || null,
    maxBidTotal: processedData?.maxBidTotal || { asset: 0, usdc: 0 },
    maxAskTotal: processedData?.maxAskTotal || { asset: 0, usdc: 0 },
    processOrderBook,
    error: workerError
  };
}


--------------------------------------------------------------------------------
workers/orderbook.worker.ts
--------------------------------------------------------------------------------
// workers/orderbook.worker.ts
import { aggregateLevels } from '../lib/orderbook';
import { NUM_ROWS } from '../lib/constants';

// Maintain flash animation state INSIDE the worker
let knownBidPrices = new Set<number>();
let knownAskPrices = new Set<number>();
let skipFlash = true;
let currentSymbol: string | null = null;
let currentGrouping: number | null = null;

self.onmessage = (event) => {
  const { rawBids, rawAsks, priceGrouping, symbol } = event.data;

  // Reset known prices if symbol or grouping changed
  if (symbol !== currentSymbol || priceGrouping !== currentGrouping) {
    knownBidPrices = new Set();
    knownAskPrices = new Set();
    skipFlash = true;
    currentSymbol = symbol;
    currentGrouping = priceGrouping;
  }

  // Aggregate with flash detection
  const bidsResult = aggregateLevels(
    rawBids,
    priceGrouping,
    true,
    knownBidPrices,  // <- Persistent state in worker
    skipFlash
  );

  const asksResult = aggregateLevels(
    rawAsks,
    priceGrouping,
    false,
    knownAskPrices,  // <- Persistent state in worker
    skipFlash
  );

  // Update known prices for next time
  knownBidPrices = bidsResult.newKnownPrices;
  knownAskPrices = asksResult.newKnownPrices;

  if(knownAskPrices.size > 1000 && knownBidPrices.size > 1000) {
    const currentOrderBookPrices = new Set([...rawBids, ...rawAsks].map(object => parseFloat(object.px)));

    knownAskPrices = new Set([...knownAskPrices].filter(p => currentOrderBookPrices.has(p)))

    knownBidPrices = new Set([...knownBidPrices].filter((bidprice) => currentOrderBookPrices.has(bidprice)))
  }

  skipFlash = false;

  // Process results
  const aggregatedBids = bidsResult.levels.slice(0, NUM_ROWS);
  const aggregatedAsks = asksResult.levels.slice(0, NUM_ROWS);
  const displayAsks = [...aggregatedAsks].reverse();

  // Calculate spread
  let spread = null;
  let bestBid = null;
  let bestAsk = null;
  if (aggregatedBids.length > 0 && aggregatedAsks.length > 0) {
    bestBid = aggregatedBids[0].price;
    bestAsk = aggregatedAsks[0].price;
    const spreadValue = bestAsk - bestBid;
    const spreadPercentage = (spreadValue / bestAsk) * 100;
    spread = { value: spreadValue, percentage: spreadPercentage };
  }

  // Calculate max totals
  const maxBidTotalAsset = aggregatedBids.length > 0
    ? Math.max(...aggregatedBids.map(b => b.total))
    : 0;
  const maxBidTotalUsdc = aggregatedBids.length > 0
    ? Math.max(...aggregatedBids.map(b => b.totalUsdc))
    : 0;

  const maxAskTotalAsset = displayAsks.length > 0
    ? Math.max(...displayAsks.map(a => a.total))
    : 0;
  const maxAskTotalUsdc = displayAsks.length > 0
    ? Math.max(...displayAsks.map(a => a.totalUsdc))
    : 0;

  // Send complete results back
  self.postMessage({
    bids: aggregatedBids,
    asks: displayAsks,
    bestBid,
    bestAsk,
    spread,
    maxBidTotal: {
      asset: maxBidTotalAsset,
      usdc: maxBidTotalUsdc
    },
    maxAskTotal: {
      asset: maxAskTotalAsset,
      usdc: maxAskTotalUsdc
    },
    symbol  // Echo back for verification
  });
};

export {};


--------------------------------------------------------------------------------
components/PositionsTable/PositionsTable.tsx
--------------------------------------------------------------------------------
import { useState } from 'react';
import type { Position } from '@/lib/types';

interface PositionsTableProps {
    userPositions: Position[];
    markPrice: number | null;
    positionsPNL: (number | string)[] | null;
}


export function PositionsTable({
    userPositions,
    markPrice,
    positionsPNL
}: PositionsTableProps) {

    const positionsTabs = [
        {
            key: 'Balances' + 1,
            name: 'Balances'
        },
        {
            key: 'Positions' + 1, name:
                'Positions'
        }, {
            key: 'Open Orders' + 1,
            name: 'Open Orders'
        }, {
            key: 'Trade History' + 1,
            name: 'Trade History'
        }, {
            key: 'Order History',
            name: 'Order History'
        }
    ]

    const currentTab = [
        { key: 'Positions' + 2, label: 'Coin' },
        {
            key: 'Positions' + 3, label: 'Size'
        }, {
            key: 'Positions' + 4,
            label: 'Position Value'
        }, {
            key: 'Entry Price',
            label: 'Entry Price'
        }, {
            key: 'Mark Price',
            label: 'Mark Price'
        }, {
            key: 'PNL',
            label: 'PNL (ROE%)'
        }, {
            key: 'lid price',
            label: 'liq price'
        }
    ];



    return (
        <div className="flex flex-col min-w-full p-3 bg-tan-500 text-white">
            <div className="flex gap-4">
                {positionsTabs.map(item => (

                    <div key={item.key}
                        className="cursor-pointer
                    hover:text-teal-400
                    hover:underline
                    hover:decoration-teal-400">
                        {item.name}
                    </div>))}
            </div>


            <div className="flex gap-9">
                {currentTab.map(item => (
                    <div
                        key={item.key}
                    >
                        {item.label}
                    </div>
                ))}
            </div>

            {/* Positions */}
            {userPositions && userPositions.length > 0 ? (
                <div className="mt-4 flex flex-col gap-3">
                    {userPositions.map((position: Position) => {
                        const entry = Number(position.inputPrice);
                        const size = Number(position.size);

                        // guard against empty inputs / NaN
                        const hasNumbers = Number.isFinite(entry) && Number.isFinite(size);

                        const mark = markPrice; // number | null

                        const dir = position.activeTradeTab === "Long" ? 1 : -1;

                        const pnlSigned =
                            mark != null && hasNumbers
                                ? (mark - entry) * size * dir
                                : null;

                        const pnlIsProfit = pnlSigned != null && pnlSigned > 0;
                        const pnlIsLoss = pnlSigned != null && pnlSigned < 0;

                        const pnlText =
                            pnlSigned == null
                                ? "-"
                                : `${pnlSigned >= 0 ? "+" : "-"}${Math.abs(pnlSigned).toFixed(2)}`;

                        return (
                            <div
                                key={position.id}
                                className="flex gap-9 bg-slate-800 min-h-13 items-center p-2 rounded"
                            >
                                {/* Side */}
                                <div
                                    className={`
          ${position.activeTradeTab === "Long" ? "bg-green-400" : "bg-red-400"}
          min-w-[4.75rem] min-h-full flex justify-center items-center
          text-gray-900 font-bold rounded
        `}
                                >
                                    {position.activeTradeTab}
                                </div>

                                {/* Coin */}
                                <div className="min-w-[4.75rem]">{position.tradeAsset}</div>

                                {/* Size */}
                                <div className="min-w-[4.75rem]">{position.size}</div>

                                {/* Entry Price */}
                                <div className="min-w-[4.75rem]">
                                    {Number.isFinite(entry) ? `$${entry.toFixed(2)}` : "-"}
                                </div>

                                {/* Mark Price */}
                                <div className="min-w-[4.75rem]">
                                    {mark != null ? `$${mark.toFixed(2)}` : "-"}
                                </div>

                                {/* PNL */}
                                <div
                                    className={`min-w-[4.75rem] font-mono ${pnlIsProfit ? "text-green-400" : pnlIsLoss ? "text-red-400" : "text-gray-400"
                                        }`}
                                >
                                    {pnlText}
                                </div>
                            </div>
                        );
                    })}

                </div>
            ) : (
                <div className="mt-8 text-center text-gray-500">
                    No open positions
                </div>
            )}
        </div>
    )
}


================================================================================
FILE STRUCTURE AFTER UPDATE 4
================================================================================

hyperliquid_widget/
|-- app/
|   |-- page.tsx                    [UPDATED - Added PriceChart]
|   |-- globals.css                 [CSS with outline:none]
|   +-- layout.tsx
|-- components/
|   |-- ui/
|   |   |-- Dropdown.tsx            [Optional key prop]
|   |   +-- TabSelector.tsx
|   |-- OrderBook/
|   |   |-- OrderBookHeader.tsx
|   |   |-- OrderBookTable.tsx      [2-column, onPriceSelect, error]
|   |   |-- OrderBookRow.tsx        [displaySide, onClick]
|   |   |-- TradesTable.tsx         [Dynamic heights]
|   |   +-- SpreadIndicator.tsx
|   |-- TradeTab/
|   |   +-- TradeTab.tsx            [Cleaned up - no comments]
|   |-- PositionsTable/
|   |   +-- PositionsTable.tsx      [Real-time PNL]
|   +-- Chart/
|       +-- Chart.tsx               [NEW - Lightweight Charts]
|-- hooks/
|   |-- useWebSocket.tsx
|   |-- useOrderBookState.tsx       [Web Worker, bestBid/Ask]
|   +-- useTrades.tsx
|-- workers/
|   +-- orderbook.worker.ts         [bestBid/Ask extraction]
+-- lib/
    |-- types.ts                    [TradeFormState, Position]
    |-- constants.ts
    |-- utils.ts
    |-- orderbook.ts
    +-- chartUtils.ts               [NEW - Candle aggregation]


================================================================================
SUMMARY OF UPDATE 4 CHANGES
================================================================================

+---------------------------+-------------------------------------------+
| Change                    | Impact                                    |
+---------------------------+-------------------------------------------+
| PriceChart Component      | Professional candlestick chart with       |
|                           | volume using TradingView Lightweight      |
|                           | Charts library                            |
+---------------------------+-------------------------------------------+
| chartUtils.ts             | Trade-to-candle aggregation algorithm     |
|                           | with interval support (1m, 5m, 15m, 1h)   |
+---------------------------+-------------------------------------------+
| New Dependencies          | lightweight-charts for charting           |
|                           | pg for future database support            |
+---------------------------+-------------------------------------------+
| Layout Refinement         | Chart + Positions on left                 |
|                           | OrderBook + TradeTab on right             |
+---------------------------+-------------------------------------------+
| TradeTab Cleanup          | Removed all commented code                |
+---------------------------+-------------------------------------------+


================================================================================
CHART RENDERING STRATEGY
================================================================================

The chart uses an efficient rendering strategy:

1. INITIAL LOAD:
   - Chart created once in useEffect (not recreated on re-renders)
   - setData() called with full candle history
   - fitContent() auto-scales to show all data

2. REAL-TIME UPDATES:
   - Only update() called with newest candle
   - Avoids expensive setData() calls
   - Smooth incremental updates

3. INTERVAL/SYMBOL CHANGE:
   - Refs reset (didSetInitialDataRef, lastRenderedTimeRef)
   - Next render triggers fresh setData()

4. RESIZE:
   - Window resize event updates chart width
   - Cleanup removes event listener


================================================================================
FUTURE IMPROVEMENTS (Suggested)
================================================================================

1. DATABASE PERSISTENCE:
   - pg dependency added but not yet used
   - Could persist positions, trades, user settings

2. CHART DATA SOURCE:
   - Currently aggregates from trades (limited history)
   - Could fetch historical candles from API

3. INTERVAL STATE:
   - interval and onIntervalChange props in PriceChart
   - Parent should manage interval state and pass candles

4. LIQUIDATION PRICE:
   - PositionsTable has "liq price" column
   - Calculation not yet implemented
